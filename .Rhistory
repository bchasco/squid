plot(mesh1, main="1st attempt")
max.edge = 1
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = max.edge)
plot(mesh1, main="1st attempt")
max.edge = 0.01
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = max.edge)
plot(mesh1, main="1st attempt")
max.edge = 0.5
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = max.edge)
plot(mesh1, main="1st attempt")
A = inla.spde.make.A(mesh=mesh, loc=data.matrix(df[ , c('locx', 'locy')]))
dim(A)
A[100:200,1:2]
formula = y ~ -1 + f(s, model=spde)
prior.median.gaus.sd = 10.5
# - Think about this value
# - Remember sd(df$y)
family = 'gaussian'
sd(df$y)
prior.median.gaus.sd = 136
# - Think about this value
# - Remember sd(df$y)
family = 'gaussian'
control.family = list(hyper = list(prec = list(
prior = "pc.prec", fixed = FALSE, param = c(prior.median.gaus.sd,0.5))))
res <- inla(formula, data=inla.stack.data(stack),
control.predictor=list(A = inla.stack.A(stack), compute=T),
# compute=T to get posterior for fitted values
family = family,
control.family = control.family,
#control.compute = list(config=T, dic=T, cpo=T, waic=T),
# - Model comparisons
control.inla = list(int.strategy='eb'),
# - faster computation
#control.inla = list(int.strategy='grid'),
# - More accurate integration over hyper-parameters
verbose=T)
local.plot.field = function(field, mesh, xlim=c(0,11), ylim=c(0,9), ...){
stopifnot(length(field) == mesh$n)
# - error when using the wrong mesh
proj = inla.mesh.projector(mesh, xlim = xlim,
ylim = ylim, dims=c(300, 300))
# - Can project from the mesh onto a 300x300 plotting grid
field.proj = inla.mesh.project(proj, field)
# - Do the projection
image.plot(list(x = proj$x, y=proj$y, z = field.proj),
xlim = xlim, ylim = ylim, col = plasma(101), ...)
}
local.plot.field(res$summary.random[['s']][['mean']], mesh)
lines(5+c(-0.5, 0.5)*(res$summary.hyperpar[2, '0.5quant']), c(1,1)*5, lwd=3)
# - add on the estimated range
axis(1); axis(2)
quilt.plot(x=df$locx,y=df$locy,z=res$summary.fitted.values$mean[1:nrow(df)],nx=40,ny=40, col = plasma(101), main="Fitted values",
zlim = range(df$y))
survey <- read.csv("SquidData.csv", sep=",", header = TRUE)
survey <- survey[!is.na(survey$Distance_Offshore_nmi),]
survey <- survey[survey$Lat>44. & survey$Lat<48,]
df = data.frame(y = survey$California_market_squid_, locx = survey$Lon, locy = survey$Lat)
spatial.scaling = 1
df$locx = (df$locx - min(df$locx))/spatial.scaling
df$locy = (df$locy - min(df$locy))/spatial.scaling
df$dist = survey$Distance_Offshore_nmi - mean(survey$Distance_Offshore_nmi)
df$y = df$y-min(df$y)
quilt.plot(x=df$locx,y=df$locy,z=df$y,nx=40,ny=40, col = plasma(101),
main = "Data")
max.edge = 0.5
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = max.edge)
plot(mesh1, main="1st attempt")
A = inla.spde.make.A(mesh=mesh, loc=data.matrix(df[ , c('locx', 'locy')]))
dim(A)
A[100:200,1:2]
Xcov = data.frame(intercept=rep(1,nrow(df)))
# - could add: area1 = (df$area==1)*1, area2 = (df$area==2)*1
# - - expands the factor covariates
# - ensure that all entries are numeric!
Xcov = as.matrix(Xcov)
colnames(Xcov)
stack <- inla.stack(tag='est',
# - Name (nametag) of the stack
# - Here: est for estimating
data=list(y=df$y),
effects=list(
# - The Model Components
s=1:mesh$n,
# - The "s" is means "spatial"
Xcov=Xcov),
# - The second is all fixed effects
A = list(A, 1)
# - First projector matrix is for 's'
# - second is for 'fixed effects'
)
sd(df$y)/10
prior.median.sd = 10; prior.median.range = 7
# - diff(range(mesh$loc[, 1]))/2
# - sd(df$y)/10
# - thisk about these, and experiment!
spde = inla.spde2.pcmatern(mesh, prior.range = c(prior.median.range, .5), prior.sigma = c(prior.median.sd, .5), constr = T)
formula = y ~ -1 + f(s, model=spde)
prior.median.gaus.sd = 136
# - Think about this value
# - Remember sd(df$y)
family = 'gaussian'
control.family = list(hyper = list(prec = list(
prior = "pc.prec", fixed = FALSE, param = c(prior.median.gaus.sd,0.5))))
res <- inla(formula, data=inla.stack.data(stack),
control.predictor=list(A = inla.stack.A(stack), compute=T),
# compute=T to get posterior for fitted values
family = family,
control.family = control.family,
#control.compute = list(config=T, dic=T, cpo=T, waic=T),
# - Model comparisons
control.inla = list(int.strategy='eb'),
# - faster computation
#control.inla = list(int.strategy='grid'),
# - More accurate integration over hyper-parameters
verbose=T)
local.plot.field = function(field, mesh, xlim=c(0,11), ylim=c(0,9), ...){
stopifnot(length(field) == mesh$n)
# - error when using the wrong mesh
proj = inla.mesh.projector(mesh, xlim = xlim,
ylim = ylim, dims=c(300, 300))
# - Can project from the mesh onto a 300x300 plotting grid
field.proj = inla.mesh.project(proj, field)
# - Do the projection
image.plot(list(x = proj$x, y=proj$y, z = field.proj),
xlim = xlim, ylim = ylim, col = plasma(101), ...)
}
local.plot.field(res$summary.random[['s']][['mean']], mesh)
lines(5+c(-0.5, 0.5)*(res$summary.hyperpar[2, '0.5quant']), c(1,1)*5, lwd=3)
# - add on the estimated range
axis(1); axis(2)
quilt.plot(x=df$locx,y=df$locy,z=res$summary.fitted.values$mean[1:nrow(df)],nx=40,ny=40, col = plasma(101), main="Fitted values",
zlim = range(df$y))
plot(mesh1, main="1st attempt")
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.2,0.2))
plot(mesh1, main="1st attempt")
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.2,0.8))
plot(mesh1, main="1st attempt")
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.9,0.8))
plot(mesh1, main="1st attempt")
stations <- unique(survey$Station)
for(i in stations){
survey$Lat[survey$Station==i] <- mean(survey$Lat[survey$Station==i])
survey$Lon[survey$Station==i] <- mean(survey$Lon[survey$Station==i])
}
df = data.frame(y = survey$California_market_squid_, locx = survey$Lon, locy = survey$Lat)
spatial.scaling = 1
df$locx = (df$locx - min(df$locx))/spatial.scaling
df$locy = (df$locy - min(df$locy))/spatial.scaling
df$dist = survey$Distance_Offshore_nmi - mean(survey$Distance_Offshore_nmi)
df$y = df$y-min(df$y)
quilt.plot(x=df$locx,y=df$locy,z=df$y,nx=40,ny=40, col = plasma(101),
main = "Data")
max.edge = 0.5
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.9,0.8))
plot(mesh1, main="1st attempt")
plot(mesh1, main="1st attempt")
A = inla.spde.make.A(mesh=mesh, loc=data.matrix(df[ , c('locx', 'locy')]))
dim(A)
A[100:200,1:2]
Xcov = data.frame(intercept=rep(1,nrow(df)))
# - could add: area1 = (df$area==1)*1, area2 = (df$area==2)*1
# - - expands the factor covariates
# - ensure that all entries are numeric!
Xcov = as.matrix(Xcov)
colnames(Xcov)
stack <- inla.stack(tag='est',
# - Name (nametag) of the stack
# - Here: est for estimating
data=list(y=df$y),
effects=list(
# - The Model Components
s=1:mesh$n,
# - The "s" is means "spatial"
Xcov=Xcov),
# - The second is all fixed effects
A = list(A, 1)
# - First projector matrix is for 's'
# - second is for 'fixed effects'
)
prior.median.sd = 10; prior.median.range = 7
# - diff(range(mesh$loc[, 1]))/2
# - sd(df$y)/10
# - thisk about these, and experiment!
spde = inla.spde2.pcmatern(mesh, prior.range = c(prior.median.range, .5), prior.sigma = c(prior.median.sd, .5), constr = T)
formula = y ~ -1 + f(s, model=spde)
prior.median.gaus.sd = 136
# - Think about this value
# - Remember sd(df$y)
family = 'gaussian'
prior.median.gaus.sd = sd(df$y)
# - Think about this value
# - Remember sd(df$y)
family = 'gaussian'
control.family = list(hyper = list(prec = list(
prior = "pc.prec", fixed = FALSE, param = c(prior.median.gaus.sd,0.5))))
res <- inla(formula, data=inla.stack.data(stack),
control.predictor=list(A = inla.stack.A(stack), compute=T),
# compute=T to get posterior for fitted values
family = family,
control.family = control.family,
#control.compute = list(config=T, dic=T, cpo=T, waic=T),
# - Model comparisons
control.inla = list(int.strategy='eb'),
# - faster computation
#control.inla = list(int.strategy='grid'),
# - More accurate integration over hyper-parameters
verbose=T)
local.plot.field = function(field, mesh, xlim=c(0,11), ylim=c(0,9), ...){
stopifnot(length(field) == mesh$n)
# - error when using the wrong mesh
proj = inla.mesh.projector(mesh, xlim = xlim,
ylim = ylim, dims=c(300, 300))
# - Can project from the mesh onto a 300x300 plotting grid
field.proj = inla.mesh.project(proj, field)
# - Do the projection
image.plot(list(x = proj$x, y=proj$y, z = field.proj),
xlim = xlim, ylim = ylim, col = plasma(101), ...)
}
local.plot.field(res$summary.random[['s']][['mean']], mesh)
lines(5+c(-0.5, 0.5)*(res$summary.hyperpar[2, '0.5quant']), c(1,1)*5, lwd=3)
# - add on the estimated range
axis(1); axis(2)
quilt.plot(x=df$locx,y=df$locy,z=res$summary.fitted.values$mean[1:nrow(df)],nx=40,ny=40, col = plasma(101), main="Fitted values",
zlim = range(df$y))
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = 0.2, cutoff = 1e-12)
plot(mesh1, main="1st attempt")
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.2,0.8), cutoff = 1e-12)
plot(mesh1, main="1st attempt")
A = inla.spde.make.A(mesh=mesh, loc=data.matrix(df[ , c('locx', 'locy')]))
dim(A)
A[100:200,1:2]
Xcov = data.frame(intercept=rep(1,nrow(df)))
# - could add: area1 = (df$area==1)*1, area2 = (df$area==2)*1
# - - expands the factor covariates
# - ensure that all entries are numeric!
Xcov = as.matrix(Xcov)
colnames(Xcov)
stack <- inla.stack(tag='est',
# - Name (nametag) of the stack
# - Here: est for estimating
data=list(y=df$y),
effects=list(
# - The Model Components
s=1:mesh$n,
# - The "s" is means "spatial"
Xcov=Xcov),
# - The second is all fixed effects
A = list(A, 1)
# - First projector matrix is for 's'
# - second is for 'fixed effects'
)
prior.median.sd = 10; prior.median.range = 7
# - diff(range(mesh$loc[, 1]))/2
# - sd(df$y)/10
# - thisk about these, and experiment!
spde = inla.spde2.pcmatern(mesh, prior.range = c(prior.median.range, .5), prior.sigma = c(prior.median.sd, .5), constr = T)
formula = y ~ -1 + f(s, model=spde)
prior.median.gaus.sd = sd(df$y)
# - Think about this value
# - Remember sd(df$y)
family = 'gaussian'
control.family = list(hyper = list(prec = list(
prior = "pc.prec", fixed = FALSE, param = c(prior.median.gaus.sd,0.5))))
res <- inla(formula, data=inla.stack.data(stack),
control.predictor=list(A = inla.stack.A(stack), compute=T),
# compute=T to get posterior for fitted values
family = family,
control.family = control.family,
#control.compute = list(config=T, dic=T, cpo=T, waic=T),
# - Model comparisons
control.inla = list(int.strategy='eb'),
# - faster computation
#control.inla = list(int.strategy='grid'),
# - More accurate integration over hyper-parameters
verbose=T)
local.plot.field = function(field, mesh, xlim=c(0,11), ylim=c(0,9), ...){
stopifnot(length(field) == mesh$n)
# - error when using the wrong mesh
proj = inla.mesh.projector(mesh, xlim = xlim,
ylim = ylim, dims=c(300, 300))
# - Can project from the mesh onto a 300x300 plotting grid
field.proj = inla.mesh.project(proj, field)
# - Do the projection
image.plot(list(x = proj$x, y=proj$y, z = field.proj),
xlim = xlim, ylim = ylim, col = plasma(101), ...)
}
local.plot.field(res$summary.random[['s']][['mean']], mesh)
lines(5+c(-0.5, 0.5)*(res$summary.hyperpar[2, '0.5quant']), c(1,1)*5, lwd=3)
# - add on the estimated range
axis(1); axis(2)
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.2,0.8), cutoff = 0.1)
plot(mesh1, main="1st attempt")
# - some chosen constant
# - results should not be sensitive to this (if you have a good mesh)
# - max.edge = diff(range(df$locx))/15
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.9,0.8), cutoff = 0.1)
plot(mesh1, main="1st attempt")
A = inla.spde.make.A(mesh=mesh, loc=data.matrix(df[ , c('locx', 'locy')]))
dim(A)
A[100:200,1:2]
Xcov = data.frame(intercept=rep(1,nrow(df)))
# - could add: area1 = (df$area==1)*1, area2 = (df$area==2)*1
# - - expands the factor covariates
# - ensure that all entries are numeric!
Xcov = as.matrix(Xcov)
colnames(Xcov)
stack <- inla.stack(tag='est',
# - Name (nametag) of the stack
# - Here: est for estimating
data=list(y=df$y),
effects=list(
# - The Model Components
s=1:mesh$n,
# - The "s" is means "spatial"
Xcov=Xcov),
# - The second is all fixed effects
A = list(A, 1)
# - First projector matrix is for 's'
# - second is for 'fixed effects'
)
prior.median.sd = 10; prior.median.range = 7
# - diff(range(mesh$loc[, 1]))/2
# - sd(df$y)/10
# - thisk about these, and experiment!
spde = inla.spde2.pcmatern(mesh, prior.range = c(prior.median.range, .5), prior.sigma = c(prior.median.sd, .5), constr = T)
formula = y ~ -1 + f(s, model=spde)
prior.median.gaus.sd = sd(df$y)
# - Think about this value
# - Remember sd(df$y)
family = 'gaussian'
control.family = list(hyper = list(prec = list(
prior = "pc.prec", fixed = FALSE, param = c(prior.median.gaus.sd,0.5))))
res <- inla(formula, data=inla.stack.data(stack),
control.predictor=list(A = inla.stack.A(stack), compute=T),
# compute=T to get posterior for fitted values
family = family,
control.family = control.family,
#control.compute = list(config=T, dic=T, cpo=T, waic=T),
# - Model comparisons
control.inla = list(int.strategy='eb'),
# - faster computation
#control.inla = list(int.strategy='grid'),
# - More accurate integration over hyper-parameters
verbose=T)
local.plot.field = function(field, mesh, xlim=c(0,11), ylim=c(0,9), ...){
stopifnot(length(field) == mesh$n)
# - error when using the wrong mesh
proj = inla.mesh.projector(mesh, xlim = xlim,
ylim = ylim, dims=c(300, 300))
# - Can project from the mesh onto a 300x300 plotting grid
field.proj = inla.mesh.project(proj, field)
# - Do the projection
image.plot(list(x = proj$x, y=proj$y, z = field.proj),
xlim = xlim, ylim = ylim, col = plasma(101), ...)
}
local.plot.field(res$summary.random[['s']][['mean']], mesh)
lines(5+c(-0.5, 0.5)*(res$summary.hyperpar[2, '0.5quant']), c(1,1)*5, lwd=3)
# - add on the estimated range
axis(1); axis(2)
quilt.plot(x=df$locx,y=df$locy,z=res$summary.fitted.values$mean[1:nrow(df)],nx=40,ny=40, col = plasma(101), main="Fitted values",
zlim = range(df$y))
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.9,0.8), cutoff = 0.1)
plot(mesh1, main="1st attempt")
source('C:/CHASCO/PROJECTS/SQUID/SpatialAnalysis_INLA.r', echo=TRUE)
local.plot.field(res$summary.random[['s']][['mean']], mesh)
source('C:/CHASCO/PROJECTS/SQUID/SpatialAnalysis_INLA.r', echo=TRUE)
local.plot.field(res$summary.random[['s']][['mean']], mesh)
library(viridisLite)
survey <- read.csv("SquidData.csv", sep=",", header = TRUE)
survey <- survey[!is.na(survey$Distance_Offshore_nmi),]
# survey <- survey[survey$Lat>44. & survey$Lat<48,]
stations <- unique(survey$Station)
df = data.frame(y = survey$California_market_squid_, locx = survey$Lon, locy = survey$Lat)
# spatial.scaling = 1
# df$locx = (df$locx - min(df$locx))/spatial.scaling
# df$locy = (df$locy - min(df$locy))/spatial.scaling
df$dist = survey$Distance_Offshore_nmi - mean(survey$Distance_Offshore_nmi)
df$y = df$y-min(df$y)
quilt.plot(x=df$locx,y=df$locy,z=df$y,nx=40,ny=40, col = plasma(101),
main = "Data")
max.edge = 0.5
mesh1 = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.9,0.8), cutoff = 0.1)
plot(mesh1, main="1st attempt")
plot(mesh1, main="1st attempt")
A = inla.spde.make.A(mesh=mesh, loc=data.matrix(df[ , c('locx', 'locy')]))
dim(A)
A[100:200,1:2]
Xcov = data.frame(intercept=rep(1,nrow(df)), dist = df$dist)
Xcov = as.matrix(Xcov)
colnames(Xcov)
stack <- inla.stack(tag='est',
# - Name (nametag) of the stack
# - Here: est for estimating
data=list(y=df$y),
effects=list(
# - The Model Components
s=1:mesh$n,
# - The "s" is means "spatial"
Xcov=Xcov),
# - The second is all fixed effects
A = list(A, 1)
# - First projector matrix is for 's'
# - second is for 'fixed effects'
)
prior.median.sd = 10; prior.median.range = 7
# - diff(range(mesh$loc[, 1]))/2
# - sd(df$y)/10
# - thisk about these, and experiment!
spde = inla.spde2.pcmatern(mesh, prior.range = c(prior.median.range, .5), prior.sigma = c(prior.median.sd, .5), constr = T)
formula = y ~ -1 + f(s, model=spde)
formula = y ~ -1 + Xcov + f(s, model=spde)
prior.median.gaus.sd = sd(df$y)
# - Think about this value
# - Remember sd(df$y)
family = 'gaussian'
control.family = list(hyper = list(prec = list(
prior = "pc.prec", fixed = FALSE, param = c(prior.median.gaus.sd,0.5))))
res <- inla(formula, data=inla.stack.data(stack),
control.predictor=list(A = inla.stack.A(stack), compute=T),
# compute=T to get posterior for fitted values
family = family,
control.family = control.family,
#control.compute = list(config=T, dic=T, cpo=T, waic=T),
# - Model comparisons
control.inla = list(int.strategy='eb'),
# - faster computation
#control.inla = list(int.strategy='grid'),
# - More accurate integration over hyper-parameters
verbose=T)
local.plot.field = function(field, mesh, xlim=c(0,11), ylim=c(0,9), ...){
stopifnot(length(field) == mesh$n)
# - error when using the wrong mesh
proj = inla.mesh.projector(mesh, xlim = xlim,
ylim = ylim, dims=c(300, 300))
# - Can project from the mesh onto a 300x300 plotting grid
field.proj = inla.mesh.project(proj, field)
# - Do the projection
image.plot(list(x = proj$x, y=proj$y, z = field.proj),
xlim = xlim, ylim = ylim, col = plasma(101), ...)
}
local.plot.field(res$summary.random[['s']][['mean']], mesh)
lines(5+c(-0.5, 0.5)*(res$summary.hyperpar[2, '0.5quant']), c(1,1)*5, lwd=3)
# - add on the estimated range
axis(1); axis(2)
quilt.plot(x=df$locx,y=df$locy,z=res$summary.fitted.values$mean[1:nrow(df)],nx=40,ny=40, col = plasma(101), main="Fitted values",
zlim = range(df$y))
local.plot.field(res$summary.random[['s']][['mean']], mesh)
lines(5+c(-0.5, 0.5)*(res$summary.hyperpar[2, '0.5quant']), c(1,1)*5, lwd=3)
# - add on the estimated range
axis(1); axis(2)
library(VAST)
search()
ls(4)
?Build_TMB_Fn
?make_model
?Data_Fn
?make_data
Method = c("Grid", "Mesh", "Spherical_mesh")[2]
grid_size_km = 25
n_x = 100   # Specify number of stations (a.k.a. "knots")
FieldConfig = c("Omega1"=1, "Epsilon1"=1, "Omega2"=1, "Epsilon2"=1)
RhoConfig = c("Beta1"=0, "Beta2"=0, "Epsilon1"=0, "Epsilon2"=0)
OverdispersionConfig = c("Eta1"=0, "Eta2"=0)
ObsModel = c(2,0)
