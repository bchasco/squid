# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid_v1_delta_glm_MVspace")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
myMap <- list()
UseP_Map <- TRUE
if(UseP_Map){
myMap <- list(eps_p_y=as.factor(rep(NA,length(Parameters$eps_p_y)))
,eps_p_s=as.factor(rep(NA,length(Parameters$eps_p_s)))
,fp_y_sd = as.factor(NA)
,fp_s_sd = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid_v1_delta_glm_MVspace")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
Data = list( n_i=n_i,
c_i=c_i,
s_i=s_i,
t_i=t_i,
lat_i = lat_i,
lat_dist = lat_dist,
X_xp=as.matrix(X_xp),
use_p_y = use_p_y,
use_c_y = use_c_y,
use_p_s = use_p_s,
use_c_s = use_c_s,
use_p_lat = use_p_lat,
use_c_lat = use_c_lat
)
Parameters = list(beta_c = rep(0,ncol(Data$X_xp)),
beta_p = rep(0,ncol(Data$X_xp)),
eps_c_s = unique(Data$s_i)*0,
eps_p_s = unique(Data$s_i)*0,
eps_c_y = unique(Data$t_i)*0,
eps_p_y = unique(Data$t_i)*0,
eps_p_lat = Data$lat_dist*0,
eps_c_lat = Data$lat_dist*0,
fc_y_sd = 0,
fp_y_sd = 0,
fc_y_rho = 0,
fp_y_rho = 0,
fc_lat_sd = 0,
fp_lat_sd = 0,
fc_lat_rho = 0,
fp_lat_rho = 0,
fs_c_sd = 0,
fs_p_sd = 0,
fsd = 0)
Random = c("eps_c_s","eps_p_s", "eps_c_y", "eps_p_y", "eps_p_lat", "eps_c_lat")
myMap <- list()
if(use_p_s){
myMap <- append(myMap,
list(eps_p_s=as.factor(rep(NA,length(Parameters$eps_p_s)))
,fp_s_sd = as.factor(NA)
)
)
}
if(use_p_s){
myMap <- append(myMap,
list(eps_p_s=as.factor(rep(NA,length(Parameters$eps_p_s)))
,fp_s_sd = as.factor(NA)
)
)
}
if(use_c_s){
myMap <- append(myMap,
list(eps_c_s=as.factor(rep(NA,length(Parameters$eps_c_s)))
,fc_s_sd = as.factor(NA)
)
)
}
if(use_p_y){
myMap <- append(myMap,
list(eps_y_s=as.factor(rep(NA,length(Parameters$eps_p_y)))
,fp_y_rho = as.factor(NA)
,fp_y_sd = as.factor(NA)
)
)
}
if(use_c_y){
myMap <- append(myMap,
list(eps_c_y=as.factor(rep(NA,length(Parameters$eps_c_y)))
,fc_y_rho = as.factor(NA)
,fc_y_sd = as.factor(NA)
)
)
}
if(use_p_lat){
myMap <- append(myMap,
list(eps_p_lat=as.factor(rep(NA,length(Parameters$eps_p_lat)))
,fp_lat_rho = as.factor(NA)
,fp_lat_sd = as.factor(NA)
)
)
}
if(use_c_lat){
myMap <- append(myMap,
list(eps_c_lat=as.factor(rep(NA,length(Parameters$eps_c_lat)))
,fc_lat_rho = as.factor(NA)
,fc_lat_sd = as.factor(NA)
)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid_v1_delta_glm_MVspace")
names(myMap)
use_p_s
myMap <- list()
if(!use_p_s){
myMap <- append(myMap,
list(eps_p_s=as.factor(rep(NA,length(Parameters$eps_p_s)))
,fp_s_sd = as.factor(NA)
)
)
}
names(myMap)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
SD
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
SD
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
#
#This is the output of the model
rep <- Obj$report()
out
atan(0)*2/3.154
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
plot(rep$eps_p_lat)
lat_i
table(lat_i)
lat_i <- data.frame(lat=round(survey$Lat,0))
lati_lu <- data.frame(lat_i=1:length(unique(lat_i)),
lat=sort(unique(lat_i)[,1]))
lati_lu
1:length(unique(lat_i))
unique(lat_i)
length(unique(survey$Station))
lat_i <- data.frame(lat=round(survey$Lat,0))
lati_lu <- data.frame(lat_i=1:length(unique(lat_i)[,1]),
lat=sort(unique(lat_i)[,1]))
lat_i <- merge(lat_i,lati_lu)$lat_i-1
lat_dist <- lati_lu$lat
lat_i
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
plot(rep$eps_c_lat)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
plot(rep$eps_c_lat)
plot(rep$eps_p_lat)
plot(rep$eps_p_y)
plot(rep$eps_c_y)
plot(rep$eps_c_y, type=
"l")
plot(rep$eps_c_y, type="l")
plot(rep$eps_p_y, type="l")
hist(rep$eps_p_s, type="l")
hist(rep$eps_p_s)
hist(rep$eps_c_s)
hist(rep$eps_p_s)
plot(Data$t_i,rep$log_chat_i)
points(Data$t_i,log(Data$c_i)
)
plot(Data$t_i,log(Data$c_i))
points(Data$t_i,rep$log_chat_i, col="blue")
plot(log(Data$c_i[Data$c_i>0]),rep$log_chat_i[Data$c_i>0], col="blue")
segments(-10.,-10,20,20)
install.packages("corrplot")
library(corrplot)
corrplot(rep$Sigma_c)
source('C:/NOAA/PROJECTS/squid/squid_VAST.R', echo=TRUE)
Record = ThorsonUtilities::bundlelist( c("Data_Set","Version","Method","grid_size_km","n_x","FieldConfig","RhoConfig","OverdispersionConfig","ObsModel","Options") )
save( Record, file=file.path(DateFile,"Record.RData"))
Record
Record = ThorsonUtilities::bundlelist( c("Data_Set","Version","Method","grid_size_km","n_x","FieldConfig","RhoConfig","OverdispersionConfig","ObsModel","Options") )
Version = get_latest_version( package="VAST" )
Record = ThorsonUtilities::bundlelist( c("Data_Set","Version","Method","grid_size_km","n_x","FieldConfig","RhoConfig","OverdispersionConfig","ObsModel","Options") )
save( Record, file=file.path(DateFile,"Record.RData"))
capture.output( Record, file=paste0(DateFile,"Record.txt"))
Method = c("Grid", "Mesh", "Spherical_mesh")[2]
grid_size_km = 25
n_x = 1000   # Specify number of stations (a.k.a. "knots")
FieldConfig = c("Omega1"=1, "Epsilon1"=1, "Omega2"=1, "Epsilon2"=1)
RhoConfig = c("Beta1"=0, "Beta2"=0, "Epsilon1"=0, "Epsilon2"=0)
OverdispersionConfig = c("Eta1"=0, "Eta2"=0)
ObsModel = c(2,0)
Options =  c("SD_site_density"=FALSE, "SD_site_logdensity"=FALSE, "Calculate_Range"=TRUE, "Calculate_effective_area"=TRUE)
# Default
if( Data_Set %in% c("GSL_american_plaice","BC_pacific_cod","EBS_pollock","SAWC_jacopever","Chatham_rise_hake","Aleutian_islands_POP")){
strata.limits <- data.frame('STRATA'="All_areas")
}
Data_Set
# Default
if( Data_Set %in% c("GSL_american_plaice","BC_pacific_cod","EBS_pollock","SAWC_jacopever","Chatham_rise_hake","Aleutian_islands_POP")){
strata.limits <- data.frame('STRATA'="All_areas")
}
# Specific (useful as examples)
if( Data_Set %in% c("WCGBTS_canary","Sim")){
# In this case, it will calculate a coastwide index, and also a separate index for each state (although the state lines are approximate)
strata.limits <- data.frame(
'STRATA' = c("Coastwide","CA","OR","WA"),
'north_border' = c(49.0, 42.0, 46.0, 49.0),
'south_border' = c(32.0, 32.0, 42.0, 46.0),
'shallow_border' = c(55, 55, 55, 55),
'deep_border' = c(1280, 1280, 1280, 1280)
)
# Override default settings for vessels
OverdispersionConfig = c("Delta1"=1, "Delta2"=1)
}
if( Data_Set %in% c("GOA_Pcod","GOA_pollock")){
# In this case, will calculating an unrestricted index and a separate index restricted to west of -140W
strata.limits <- data.frame(
'STRATA' = c("All_areas", "west_of_140W"),
'west_border' = c(-Inf, -Inf),
'east_border' = c(Inf, -140)
)
}
if( Data_Set %in% c("GB_spring_haddock","GB_fall_haddock")){
# For NEFSC indices, strata must be specified as a named list of area codes
strata.limits = list( 'Georges_Bank'=c(1130, 1140, 1150, 1160, 1170, 1180, 1190, 1200, 1210, 1220, 1230, 1240, 1250, 1290, 1300) )
}
if( Data_Set %in% c("Iceland_cod")){
strata.limits = data.frame( 'STRATA'="All_areas" )
# Turn off all spatial, temporal, and spatio-temporal variation in probability of occurrence, because they occur almost everywhere
FieldConfig = c("Omega1"=0, "Epsilon1"=0, "Omega2"=1, "Epsilon2"=1)
# Use an observation model that fixes encounter probability at 100% for years where its encoutered everywhere.
ObsModel = c(2,3)
}
strata.limits
Region = switch( Data_Set, "Chatham_rise_hake"="New_Zealand",
"WCGBTS_canary"="California_current",
"GSL_american_plaice"="Gulf_of_St_Lawrence",
"BC_pacific_cod"="British_Columbia",
"EBS_pollock"="Eastern_Bering_Sea",
"GOA_Pcod"="Gulf_of_Alaska",
"GOA_pollock"="Gulf_of_Alaska",
"GB_spring_haddock"="Northwest_Atlantic",
"GB_fall_haddock"="Northwest_Atlantic",
"SAWC_jacopever"="South_Africa",
"Aleutian_islands_POP"="Aleutian_Islands",
"Other")
if(Data_Set=="WCGBTS_canary"){
data( WCGBTS_Canary_example, package="FishStatsUtils" )
Year = as.numeric(sapply(WCGBTS_Canary_example[,'PROJECT_CYCLE'], FUN=function(Char){strsplit(as.character(Char)," ")[[1]][2]}))
Data_Geostat = data.frame( "Catch_KG"=WCGBTS_Canary_example[,'HAUL_WT_KG'], "Year"=Year, "Vessel"=paste(WCGBTS_Canary_example[,"VESSEL"],Year,sep="_"), "AreaSwept_km2"=WCGBTS_Canary_example[,"AREA_SWEPT_HA"]/1e2, "Lat"=WCGBTS_Canary_example[,'BEST_LAT_DD'], "Lon"=WCGBTS_Canary_example[,'BEST_LON_DD'], "Pass"=WCGBTS_Canary_example[,'PASS']-1.5)
}
if( Data_Set %in% c("BC_pacific_cod")){
data( BC_pacific_cod_example, package="FishStatsUtils" )
Data_Geostat = data.frame( "Catch_KG"=BC_pacific_cod_example[,'PCOD_WEIGHT'], "Year"=BC_pacific_cod_example[,'Year'], "Vessel"="missing", "AreaSwept_km2"=BC_pacific_cod_example[,'TOW.LENGTH..KM.']/100, "Lat"=BC_pacific_cod_example[,'LAT'], "Lon"=BC_pacific_cod_example[,'LON'], "Pass"=0)
}
if( Data_Set %in% c("GSL_american_plaice")){
data( GSL_american_plaice, package="FishStatsUtils" )
Print_Message( "GSL_american_plaice" )
Data_Geostat = data.frame( "Year"=GSL_american_plaice[,'year'], "Lat"=GSL_american_plaice[,'latitude'], "Lon"=GSL_american_plaice[,'longitude'], "Vessel"="missing", "AreaSwept_km2"=GSL_american_plaice[,'swept'], "Catch_KG"=GSL_american_plaice[,'biomass']*GSL_american_plaice[,'vstd'] )
}
if(Data_Set=="EBS_pollock"){
data( EBS_pollock_data, package="FishStatsUtils" )
Data_Geostat = data.frame( "Catch_KG"=EBS_pollock_data[,'catch'], "Year"=EBS_pollock_data[,'year'], "Vessel"="missing", "AreaSwept_km2"=0.01, "Lat"=EBS_pollock_data[,'lat'], "Lon"=EBS_pollock_data[,'long'], "Pass"=0)
}
if(Data_Set=="GOA_Pcod"){
data( GOA_pacific_cod , package="FishStatsUtils")
Data_Geostat = data.frame( "Catch_KG"=GOA_pacific_cod[,'catch'], "Year"=GOA_pacific_cod[,'year'], "Vessel"="missing", "AreaSwept_km2"=0.01, "Lat"=GOA_pacific_cod[,'lat'], "Lon"=GOA_pacific_cod[,'lon'], "Pass"=0)
}
if(Data_Set=="GOA_pollock"){
data( GOA_walleye_pollock, package="FishStatsUtils" )
Data_Geostat = data.frame( "Catch_KG"=GOA_walleye_pollock[,'catch'], "Year"=GOA_walleye_pollock[,'year'], "Vessel"="missing", "AreaSwept_km2"=0.01, "Lat"=GOA_walleye_pollock[,'lat'], "Lon"=GOA_walleye_pollock[,'lon'], "Pass"=0)
}
if(Data_Set=="Aleutian_islands_POP"){
data( AI_pacific_ocean_perch, package="FishStatsUtils" )
Data_Geostat = data.frame( "Catch_KG"=AI_pacific_ocean_perch[,'cpue..kg.km.2.'], "Year"=AI_pacific_ocean_perch[,'year'], "Vessel"="missing", "AreaSwept_km2"=1, "Lat"=AI_pacific_ocean_perch[,'start.latitude'], "Lon"=AI_pacific_ocean_perch[,'start.longitude'], "Pass"=0)
}
if( Data_Set=="GB_spring_haddock"){
data( georges_bank_haddock_spring, package="FishStatsUtils" )
Print_Message( "GB_haddock" )
Data_Geostat = data.frame( "Catch_KG"=georges_bank_haddock_spring[,'CATCH_WT_CAL'], "Year"=georges_bank_haddock_spring[,'YEAR'], "Vessel"="missing", "AreaSwept_km2"=0.0112*1.852^2, "Lat"=georges_bank_haddock_spring[,'LATITUDE'], "Lon"=georges_bank_haddock_spring[,'LONGITUDE'])
}
if( Data_Set=="GB_fall_haddock"){
data( georges_bank_haddock_fall, package="FishStatsUtils" )
Print_Message( "GB_haddock" )
Data_Geostat = data.frame( "Catch_KG"=georges_bank_haddock_fall[,'CATCH_WT_CAL'], "Year"=georges_bank_haddock_fall[,'YEAR'], "Vessel"="missing", "AreaSwept_km2"=0.0112*1.852^2, "Lat"=georges_bank_haddock_fall[,'LATITUDE'], "Lon"=georges_bank_haddock_fall[,'LONGITUDE'])
}
if( Data_Set=="SAWC_jacopever"){
data( south_africa_westcoast_jacopever, package="FishStatsUtils" )
Data_Geostat = data.frame( "Catch_KG"=south_africa_westcoast_jacopever[,'HELDAC'], "Year"=south_africa_westcoast_jacopever[,'Year'], "Vessel"="missing", "AreaSwept_km2"=south_africa_westcoast_jacopever[,'area_swept_nm2']*1.852^2, "Lat"=south_africa_westcoast_jacopever[,'cen_lat'], "Lon"=south_africa_westcoast_jacopever[,'cen_long'])
}
if( Data_Set %in% c("Iceland_cod")){
# WARNING:  This data set has not undergone much evaluation for spatio-temporal analysis
data( iceland_cod, package="FishStatsUtils" )
Data_Geostat = data.frame( "Catch_KG"=iceland_cod[,'Catch_b'], "Year"=iceland_cod[,'year'], "Vessel"=1, "AreaSwept_km2"=iceland_cod[,'towlength'], "Lat"=iceland_cod[,'lat1'], "Lon"=iceland_cod[,'lon1'])
}
if( Data_Set %in% c("Chatham_rise_hake")){
data( chatham_rise_hake, package="FishStatsUtils" )
Data_Geostat = data.frame( "Catch_KG"=chatham_rise_hake[,'Hake_kg_per_km2'], "Year"=chatham_rise_hake[,'Year'], "Vessel"=1, "AreaSwept_km2"=1, "Lat"=chatham_rise_hake[,'Lat'], "Lon"=chatham_rise_hake[,'Lon'])
}
Data_Geostat = na.omit( Data_Geostat )
Data_Geostat
if( Region %in% c("California_current","Eastern_Bering_Sea","Gulf_of_Alaska","Aleutian_Islands","Northwest_Atlantic","Gulf_of_St_Lawrence","New_Zealand") ){
Extrapolation_List = make_extrapolation_info( Region=Region, strata.limits=strata.limits )
}
if( Region == "British_Columbia" ){
Extrapolation_List = make_extrapolation_info( Region=Region, strata.limits=strata.limits, strata_to_use=c("HS","QCS") )
}
if( Region == "South_Africa" ){
Extrapolation_List = make_extrapolation_info( Region=Region, strata.limits=strata.limits, region="west_coast" )
}
if( Region == "Other" ){
Extrapolation_List = make_extrapolation_info( Region=Region, strata.limits=strata.limits, observations_LL=Data_Geostat[,c('Lat','Lon')], maximum_distance_from_sample=15 )
}
Extrapolation_List
Spatial_List = make_spatial_info( grid_size_km=grid_size_km, n_x=n_x, Method=Method, Lon_i=Data_Geostat[,'Lon'], Lat_i=Data_Geostat[,'Lat'], Extrapolation_List=Extrapolation_List, DirPath=DateFile, Save_Results=FALSE, fine_scale=TRUE )
# Add knots to Data_Geostat
Data_Geostat = cbind( Data_Geostat, "knot_i"=Spatial_List$knot_i )
names(Data_Geostat)
TmbData = make_data("Version"=Version, "FieldConfig"=FieldConfig, "OverdispersionConfig"=OverdispersionConfig, "RhoConfig"=RhoConfig, "ObsModel"=ObsModel, "c_i"=rep(0,nrow(Data_Geostat)), "b_i"=Data_Geostat[,'Catch_KG'], "a_i"=Data_Geostat[,'AreaSwept_km2'], "v_i"=as.numeric(Data_Geostat[,'Vessel'])-1, "s_i"=Data_Geostat[,'knot_i']-1, "t_i"=Data_Geostat[,'Year'], "spatial_list"=Spatial_List, "Options"=Options )
TmbList = make_model("TmbData"=TmbData, "RunDir"=DateFile, "Version"=Version, "RhoConfig"=RhoConfig, "loc_x"=Spatial_List$loc_x, "Method"=Spatial_List$Method)
Obj = TmbList[["Obj"]]
Opt = TMBhelper::Optimize( obj=Obj, lower=TmbList[["Lower"]], upper=TmbList[["Upper"]], getsd=TRUE, savedir=DateFile, bias.correct=TRUE, newtonsteps=1, bias.correct.control=list(sd=FALSE, split=NULL, nsplit=1, vars_to_correct="Index_cyl") )
source('C:/NOAA/PROJECTS/squid/squid_VAST.R', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_VAST.R', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_VAST.R', echo=TRUE)
Opt
Obj
library(INLA); library(sp); library(fields)
# library(geoR)
library(viridisLite)
library(TMB)
library(ggthemes)
library(maps)
require(sp)
require(maptools)
require(ggplot2)
survey <- read.csv("comb_catches.txt", sep="\t", header = TRUE)
stations <- unique(survey$Station_Code)
df = data.frame(y = log(survey$CPUE),
locx = survey$Lon,
locy = survey$Lat)
# spatial.scaling = 1
# df$locx = (df$locx - min(df$locx))/spatial.scaling
# df$locy = (df$locy - min(df$locy))/spatial.scaling
df$dist = survey$Distance_Offshore_nmi - mean(survey$Distance_Offshore_nmi)
df$y = df$y-min(df$y)
max.edge = 0.99
mesh = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.n = 200, cutoff = 0.1)
try(dyn.unload("squid"))
compile("squid.cpp")
dyn.load("squid")
n_i <- nrow(survey)
n_x <- mesh$n
n_t <- length(unique(survey$Year))
n_p <- 1 #number of covariates
x_s <- mesh$idx$loc - 1
x_s
c_i <- survey$CPUE
s_i <- data.frame(Station=survey$Station)
plot(mesh)
si_lu <- data.frame(s_i=1:length(unique(survey$Station)),
Station=unique(survey$Station))
s_i <- merge(s_i,si_lu)$s_i-1
t_i <- survey[,'Year']-min(survey[,'Year'])
X_xp <- as.matrix(rep(1,n_x),n_x,1)
spde = inla.spde2.matern(mesh)
Data = list( n_i=n_i,
n_x=n_x,
n_t=n_t,
n_p=ncol(X_xp),
x_s=x_s,
c_i=c_i,
s_i=s_i,
t_i=t_i,
X_xp=X_xp,
G0=spde$param.inla$M0,
G1=spde$param.inla$M1,
G2=spde$param.inla$M2)
Parameters = list(fp= 0,
alpha=rep(0.0),
fsd = 5.0,
phi=0.0,
log_tau_E=1.0,
log_tau_O=1.0,
log_kappa=0.0,
rho=0.5,
fs_sd = 0,
eps_s = unique(Data$s_i)*0,
eps_p = unique(Data$s_i)*0,
fp_sd = 0,
Epsilon_input=matrix(0,nrow=mesh$n,ncol=Data$n_t),
Omega_input=rep(0,mesh$n))
Random = c("Epsilon_input","Omega_input", "eps_s","eps_p")
# library(TMBhelper)
myMap <- list()
UseMap <- FALSE
if(UseMap){
myMap <- list(Epsilon_input=as.factor(matrix(NA,nrow=mesh$n,ncol=Data$n_t))
,Omega_input=as.factor(rep(NA,mesh$n))
,phi = as.factor(NA)
,log_tau_E = as.factor(NA)
,log_tau_O = as.factor(NA)
,log_kappa = as.factor(NA)
,rho = as.factor(NA)
)
}
UseP_Map <- TRUE
if(UseP_Map){
myMap <- list(eps_p=as.factor(rep(NA,length(Parameters$eps_p)))
,eps_s=as.factor(rep(NA,length(Parameters$eps_s)))
,fp_sd = as.factor(NA)
,fs_sd = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
# SD <- sdreport(Obj)
#
#This is the output of the model
rep <- Obj$report()
?Vast::Data_Fn
library(VAST)
?Vast::Data_Fn
?VAST::Data_Fn
library(VAST)
<<<<<<< HEAD
devtools::install_github("james-thorson/VAST")
devtools::install_github("james-thorson/VAST")
devtools::install_github("james-thorson/VAST")
#Start by bringing in the flat data.
raw <- read.csv("comb_catches.csv")
head(raw)
library(VAST)
library(TMB)
library(devtools)
install_github("james-thorson/VAST", INSTALL_opts="--no-staged-install")
install.packages(:glue)
install.packages("glue")
install.packages("glue")
install.packages("backports")
install.packages("ellipsis")
devtools::install_github("james-thorson/VAST")
head(raw)
version
library(devtools)
install.github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install_github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install_github("james-thorson/VAST", INSTALL_opts="--no-staged-install")
library(VAST)
# Load packages
library(TMB)
library(VAST)
# load data set
# see `?load_example` for list of stocks with example data
# that are installed automatically with `FishStatsUtils`.
example = load_example( data_set="EBS_pollock" )
# Make settings (turning off bias.correct to save time for example)
settings = make_settings( n_x=100,
Region=example$Region,
purpose="index",
strata.limits=example$strata.limits,
bias.correct=FALSE )
# Run model
fit = fit_model( settings=settings,
Lat_i=example$sampling_data[,'Lat'],
Lon_i=example$sampling_data[,'Lon'],
t_i=example$sampling_data[,'Year'],
c_i=rep(0,nrow(example$sampling_data)),
b_i=example$sampling_data[,'Catch_KG'],
a_i=example$sampling_data[,'AreaSwept_km2'],
v_i=example$sampling_data[,'Vessel'] )
# Plot results
plot( fit )
=======
?VAST::Data_Fn
?VAST::make_data
>>>>>>> 81176613ce7f5ee768fb66df580210ca23d95990
head(1)raw
head(raw)
#Start by bringing in the flat data.
raw <- read.csv("comb_catches.csv")
head(raw)
raw[,c('Extension')]
names(raw)
