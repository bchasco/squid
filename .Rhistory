log_tau_O=1.0,
log_kappa=0.0,
rho=0.5,
fs_sd = 0,
eps_s = unique(Data$s_i)*0,
eps_p = unique(Data$s_i)*0,
fp_sd = 0,
Epsilon_input=matrix(0,nrow=mesh$n,ncol=Data$n_t),
Omega_input=rep(0,mesh$n))
Random = c("Epsilon_input","Omega_input", "eps_s","eps_p")
# library(TMBhelper)
myMap <- list()
UseMap <- FALSE
if(UseMap){
myMap <- list(Epsilon_input=as.factor(matrix(NA,nrow=mesh$n,ncol=Data$n_t))
,Omega_input=as.factor(rep(NA,mesh$n))
,phi = as.factor(NA)
,log_tau_E = as.factor(NA)
,log_tau_O = as.factor(NA)
,log_kappa = as.factor(NA)
,rho = as.factor(NA)
)
}
UseP_Map <- TRUE
if(UseP_Map){
myMap <- list(eps_p=as.factor(rep(NA,length(Parameters$eps_p)))
,eps_s=as.factor(rep(NA,length(Parameters$eps_s)))
,fp_sd = as.factor(NA)
,fs_sd = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
# SD <- sdreport(Obj)
#
#This is the output of the model
rep <- Obj$report()
n <- 50 #Raster cells
xlim <- c(-125.5,-123.5) #longitude limits
ylim <- c(44,48.5) #latitude limits
#Projected mesh based on raster cells
proj = inla.mesh.projector(mesh,
xlim = xlim,
ylim = ylim,
dims=c(n, n))
#Project the deviates for the inla mesh
field.proj = inla.mesh.project(proj, rep$Omega_x+rep$Epsilon_xt[,1])
#Create the data.frame for doing the plotting
DF <- data.frame(yr=rep(unique(survey$Year)[1],n*n),
x=rep(proj$x,n),
y=rep(proj$y,each=n),
dens = exp(c(as.matrix(field.proj))))
for(i in 2:ncol(rep$Epsilon_xt)){
field.proj = inla.mesh.project(proj, rep$Omega_x+rep$Epsilon_xt[,i])
DF_tmp <- data.frame(yr=rep(unique(survey$Year)[i],n*n),
x=rep(proj$x,n),
y=rep(proj$y,each=n),
dens = exp(c(as.matrix(field.proj))))
DF <- rbind(DF,DF_tmp)
}
DF$yr <- as.factor(DF$yr)
# get the map, don't plot it but `fill` gets us named 'map' polygons
world <- map("world", fill=TRUE, plot=FALSE)
# convert the 'map' to something we can work with via geom_map
IDs <- sapply(strsplit(world$names, ":"), function(x) x[1])
#Load some report object from TMB
load("TMBout.rData")
#Everything below here is for plotting
#Load the libraries you need
library(INLA)
library(INLA); library(sp); library(fields)
library(geoR)
install.packages("geoR")
#Everything below here is for plotting
#Load the libraries you need
library(INLA)
library(INLA); library(sp); library(fields)
library(geoR)
library(viridisLite)
library(TMB)
library(ggthemes)
library(maps)
require(sp)
require(maptools)
require(ggplot2)
n <- 50 #Raster cells
xlim <- c(-125.5,-123.5) #longitude limits
ylim <- c(44,48.5) #latitude limits
#Projected mesh based on raster cells
proj = inla.mesh.projector(mesh,
xlim = xlim,
ylim = ylim,
dims=c(n, n))
#Project the deviates for the inla mesh
field.proj = inla.mesh.project(proj, rep$Omega_x+rep$Epsilon_xt[,1])
mesh
n
n
#Project the deviates for the inla mesh
field.proj = inla.mesh.project(proj, rep$Omega_x+rep$Epsilon_xt[,1])
n <- 100 #Raster cells
xlim <- c(-125.5,-123.5) #longitude limits
ylim <- c(44,48.5) #latitude limits
#Projected mesh based on raster cells
proj = inla.mesh.projector(mesh,
xlim = xlim,
ylim = ylim,
dims=c(n, n))
#Project the deviates for the inla mesh
field.proj = inla.mesh.project(proj, rep$Omega_x+rep$Epsilon_xt[,1])
rep$Omega_x
rep$Epsilon_xt[,1]
n <- 200 #Raster cells
xlim <- c(-125.5,-123.5) #longitude limits
ylim <- c(44,48.5) #latitude limits
#Projected mesh based on raster cells
proj = inla.mesh.projector(mesh,
xlim = xlim,
ylim = ylim,
dims=c(n, n))
#Project the deviates for the inla mesh
field.proj = inla.mesh.project(proj, rep$Omega_x+rep$Epsilon_xt[,1])
#Create the data.frame for doing the plotting
DF <- data.frame(yr=rep(unique(survey$Year)[1],n*n),
x=rep(proj$x,n),
y=rep(proj$y,each=n),
dens = exp(c(as.matrix(field.proj))))
for(i in 2:ncol(rep$Epsilon_xt)){
field.proj = inla.mesh.project(proj, rep$Omega_x+rep$Epsilon_xt[,i])
DF_tmp <- data.frame(yr=rep(unique(survey$Year)[i],n*n),
x=rep(proj$x,n),
y=rep(proj$y,each=n),
dens = exp(c(as.matrix(field.proj))))
DF <- rbind(DF,DF_tmp)
}
# get the map, don't plot it but `fill` gets us named 'map' polygons
world <- map("world", fill=TRUE, plot=FALSE)
# convert the 'map' to something we can work with via geom_map
IDs <- sapply(strsplit(world$names, ":"), function(x) x[1])
world <- map2SpatialPolygons(world, IDs=IDs, proj4string=CRS("+proj=longlat +datum=WGS84"))
# this does the magic for geom_map
world_map <- fortify(world)
#You can subset the years of the inla output
myYears <- DF$yr%in%c(as.character(1998:2019))
#This is the ggplot
p <- ggplot(DF[myYears,], aes(x, y)) +
geom_raster(aes(x, y, fill = dens)) +
scale_fill_gradientn(colours=c("#0000FFFF","#FFFFFFFF","#FF0000FF")) +
facet_wrap(~yr, ncol=3) +
scale_x_continuous(limits = c(min(DF$x),max(DF$x)), expand = c(0, 0)) +
scale_y_continuous(limits = c(min(DF$y),max(DF$y)), expand = c(0, 0)) +
theme_bw() +
ylab("Latitude") +
xlab("Longitude") +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank()) +
annotation_map(map_data("world")) +
theme_bw()+theme(plot.background = element_blank(),panel.grid.major = element_blank()
,panel.grid.minor = element_blank()) +labs(title="",y="", x="")+
theme(axis.title.x = element_text(face="bold", size=8,colour = rgb(0,0,0)),axis.text.x = element_text(size=8,colour = rgb(0,0,0)))+
theme(axis.title.y = element_text(face="bold", size=8,colour = rgb(0,0,0)),axis.text.y = element_text(size=8,colour = rgb(0,0,0)))+
theme(plot.title = element_text(lineheight=.8, face="bold",size=10,colour = rgb(0,0,0)))+
theme(
panel.background = element_rect(fill = "transparent",colour = NA),
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_rect(colour = "black", fill=NA, size=0.5))+
theme(legend.position="none")
# pdf("SpatialAnalysis_INLA.pdf", width = 7, height=10)
print(p)
names(rep)
dim(rep$Epsilon_xt)
rep$fs_sd
rep$f_sd
rep$rho
rep$fsd
rep$Range
rep$SigmaE
rep$Sigma)
rep$SigmaO
rep$phi
hist(exp(rep$log_chat_i))
hist((rep$log_chat_i))
install.packages("VAST")
library(VAST)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
#
#This is the output of the model
rep <- Obj$report()
rep$Sigma_c
dim(rep$Sigma_c)
length(rep$eps_c_lat)
unique(Data$lat_i)
lat_i
lat_dist
Data = list( n_i=n_i,
c_i=c_i,
s_i=s_i,
t_i=t_i,
lat_i = lat_i,
lat_dist = lat_dist,
X_xp=as.matrix(X_xp))
Parameters = list(beta_c = rep(0,ncol(Data$X_xp)),
beta_p = rep(0,ncol(Data$X_xp)),
eps_c_s = unique(Data$s_i)*0,
eps_p_s = unique(Data$s_i)*0,
eps_c_y = unique(Data$t_i)*0,
eps_p_y = unique(Data$t_i)*0,
eps_p_lat = Data$lat_dist*0,
eps_c_lat = Data$lat_dist*0,
fc_y_sd = 0,
fp_y_sd = 0,
fc_y_rho = 0,
fp_y_rho = 0,
fc_lat_sd = 0,
fp_lat_sd = 0,
fc_lat_rho = 0,
fp_lat_rho = 0,
fs_c_sd = 0,
fs_p_sd = 0,
fsd = 0)
Random = c("eps_c_s","eps_p_s", "eps_c_y", "eps_p_y", "eps_p_lat", "eps_c_lat")
myMap <- list()
UseP_Map <- FALSE
if(UseP_Map){
myMap <- list(eps_p_y=as.factor(rep(NA,length(Parameters$eps_p_y)))
,eps_c_s=as.factor(rep(NA,length(Parameters$eps_c_s)))
,fs_p_sd = as.factor(NA)
,fs_c_sd = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid_v1_delta_glm_MVspace")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
SD <- sdreport(Obj)
#
#This is the output of the model
rep <- Obj$report()
rep$Sigma_c
rep$eps_c_lat
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
rep$eps_c_lat
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
rep$eps_c_lat
rep$Sigma_c
0.9 ^ (lat_dist-44.2)
lat_dist
0.9 ^ (lat_dist-44.7)
0.9 ^ (abs(lat_dist-44.7))
lat_i <- data.frame(lat=round(survey$Lat,1))
lati_lu <- data.frame(lat_i=1:length(unique(lat_i)),
lat=sort(unique(lat_i)))
lat_i <- merge(lat_i,lati_lu)$lat_i-1
lat_dist <- lati_lu$lat
lat_i <- data.frame(lat=round(survey$Lat,1))
lati_lu <- data.frame(lat_i=1:length(unique(lat_i)),
lat=sort(unique(lat_i)))
lat_i <- data.frame(lat=round(survey$Lat,1))
sort(unique(lat_i))
lati_lu <- data.frame(lat_i=1:length(unique(lat_i)),
lat=order(unique(lat_i)))
lat_i <- merge(lat_i,lati_lu)$lat_i-1
lat_dist <- lati_lu$lat
lat_dist
lat_i <- data.frame(lat=round(survey$Lat,1))
unique(lat_i)
sort(unique(lat_i))
sort(unique(lat_i)[,1])
lati_lu <- data.frame(lat_i=1:length(unique(lat_i)),
lat=order(unique(lat_i)[,1]))
lat_i <- merge(lat_i,lati_lu)$lat_i-1
lat_dist <- lati_lu$lat
lat_dist
lat_i <- data.frame(lat=round(survey$Lat,1))
lati_lu <- data.frame(lat_i=1:length(unique(lat_i)),
lat=sort(unique(lat_i)[,1]))
lat_i <- merge(lat_i,lati_lu)$lat_i-1
lat_dist <- lati_lu$lat
lat_dist
0.9 ^ (abs(lat_dist-37.2))
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
SD
rep$eps_c_lat
plot(rep$eps_c_lat)
plot(rep$eps_c_s)
plot(rep$eps_p_s)
plot(rep$eps_p_lat)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
SD
plot(rep$eps_p_s)
plot(rep$eps_c_s)
plot(rep$eps_c_lat)
plot(rep$eps_p_lat)
UseP_Map <- TRUE
if(UseP_Map){
myMap <- list(eps_p_y=as.factor(rep(NA,length(Parameters$eps_p_y)))
,eps_c_s=as.factor(rep(NA,length(Parameters$eps_c_s)))
,fs_p_sd = as.factor(NA)
,fs_c_sd = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid_v1_delta_glm_MVspace")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
myMap <- list()
UseP_Map <- TRUE
if(UseP_Map){
myMap <- list(eps_p_y=as.factor(rep(NA,length(Parameters$eps_p_y)))
,eps_p_s=as.factor(rep(NA,length(Parameters$eps_p_s)))
,fp_y_sd = as.factor(NA)
,fp_s_sd = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid_v1_delta_glm_MVspace")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
Data = list( n_i=n_i,
c_i=c_i,
s_i=s_i,
t_i=t_i,
lat_i = lat_i,
lat_dist = lat_dist,
X_xp=as.matrix(X_xp),
use_p_y = use_p_y,
use_c_y = use_c_y,
use_p_s = use_p_s,
use_c_s = use_c_s,
use_p_lat = use_p_lat,
use_c_lat = use_c_lat
)
Parameters = list(beta_c = rep(0,ncol(Data$X_xp)),
beta_p = rep(0,ncol(Data$X_xp)),
eps_c_s = unique(Data$s_i)*0,
eps_p_s = unique(Data$s_i)*0,
eps_c_y = unique(Data$t_i)*0,
eps_p_y = unique(Data$t_i)*0,
eps_p_lat = Data$lat_dist*0,
eps_c_lat = Data$lat_dist*0,
fc_y_sd = 0,
fp_y_sd = 0,
fc_y_rho = 0,
fp_y_rho = 0,
fc_lat_sd = 0,
fp_lat_sd = 0,
fc_lat_rho = 0,
fp_lat_rho = 0,
fs_c_sd = 0,
fs_p_sd = 0,
fsd = 0)
Random = c("eps_c_s","eps_p_s", "eps_c_y", "eps_p_y", "eps_p_lat", "eps_c_lat")
myMap <- list()
if(use_p_s){
myMap <- append(myMap,
list(eps_p_s=as.factor(rep(NA,length(Parameters$eps_p_s)))
,fp_s_sd = as.factor(NA)
)
)
}
if(use_p_s){
myMap <- append(myMap,
list(eps_p_s=as.factor(rep(NA,length(Parameters$eps_p_s)))
,fp_s_sd = as.factor(NA)
)
)
}
if(use_c_s){
myMap <- append(myMap,
list(eps_c_s=as.factor(rep(NA,length(Parameters$eps_c_s)))
,fc_s_sd = as.factor(NA)
)
)
}
if(use_p_y){
myMap <- append(myMap,
list(eps_y_s=as.factor(rep(NA,length(Parameters$eps_p_y)))
,fp_y_rho = as.factor(NA)
,fp_y_sd = as.factor(NA)
)
)
}
if(use_c_y){
myMap <- append(myMap,
list(eps_c_y=as.factor(rep(NA,length(Parameters$eps_c_y)))
,fc_y_rho = as.factor(NA)
,fc_y_sd = as.factor(NA)
)
)
}
if(use_p_lat){
myMap <- append(myMap,
list(eps_p_lat=as.factor(rep(NA,length(Parameters$eps_p_lat)))
,fp_lat_rho = as.factor(NA)
,fp_lat_sd = as.factor(NA)
)
)
}
if(use_c_lat){
myMap <- append(myMap,
list(eps_c_lat=as.factor(rep(NA,length(Parameters$eps_c_lat)))
,fc_lat_rho = as.factor(NA)
,fc_lat_sd = as.factor(NA)
)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid_v1_delta_glm_MVspace")
names(myMap)
use_p_s
myMap <- list()
if(!use_p_s){
myMap <- append(myMap,
list(eps_p_s=as.factor(rep(NA,length(Parameters$eps_p_s)))
,fp_s_sd = as.factor(NA)
)
)
}
names(myMap)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
SD
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
SD
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
#
#This is the output of the model
rep <- Obj$report()
out
atan(0)*2/3.154
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
plot(rep$eps_p_lat)
lat_i
table(lat_i)
lat_i <- data.frame(lat=round(survey$Lat,0))
lati_lu <- data.frame(lat_i=1:length(unique(lat_i)),
lat=sort(unique(lat_i)[,1]))
lati_lu
1:length(unique(lat_i))
unique(lat_i)
length(unique(survey$Station))
lat_i <- data.frame(lat=round(survey$Lat,0))
lati_lu <- data.frame(lat_i=1:length(unique(lat_i)[,1]),
lat=sort(unique(lat_i)[,1]))
lat_i <- merge(lat_i,lati_lu)$lat_i-1
lat_dist <- lati_lu$lat
lat_i
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
plot(rep$eps_c_lat)
source('C:/NOAA/PROJECTS/squid/squid_v1_delta_glm_MVspace.r', echo=TRUE)
plot(rep$eps_c_lat)
plot(rep$eps_p_lat)
plot(rep$eps_p_y)
plot(rep$eps_c_y)
plot(rep$eps_c_y, type=
"l")
plot(rep$eps_c_y, type="l")
plot(rep$eps_p_y, type="l")
hist(rep$eps_p_s, type="l")
hist(rep$eps_p_s)
hist(rep$eps_c_s)
hist(rep$eps_p_s)
plot(Data$t_i,rep$log_chat_i)
points(Data$t_i,log(Data$c_i)
)
plot(Data$t_i,log(Data$c_i))
points(Data$t_i,rep$log_chat_i, col="blue")
plot(log(Data$c_i[Data$c_i>0]),rep$log_chat_i[Data$c_i>0], col="blue")
segments(-10.,-10,20,20)
install.packages("corrplot")
library(corrplot)
corrplot(rep$Sigma_c)
