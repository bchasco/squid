myMap <- list(#Epsilon_input=as.factor(matrix(NA,nrow=mesh$n,ncol=Data$n_t))
Omega_input=as.factor(rep(NA,mesh$n))
,phi = as.factor(NA)
# ,log_tau_E = as.factor(NA)
,log_tau_O = as.factor(NA)
,log_kappa = as.factor(NA)
,rho = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
# library(TMBhelper)
myMap <- list()
UseMap <- FALSE
if(UseMap){
myMap <- list(#Epsilon_input=as.factor(matrix(NA,nrow=mesh$n,ncol=Data$n_t))
Omega_input=as.factor(rep(NA,mesh$n))
,phi = as.factor(NA)
# ,log_tau_E = as.factor(NA)
,log_tau_O = as.factor(NA)
,log_kappa = as.factor(NA)
,rho = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
# library(TMBhelper)
myMap <- list()
UseMap <- TRUE
if(UseMap){
myMap <- list(#Epsilon_input=as.factor(matrix(NA,nrow=mesh$n,ncol=Data$n_t))
Omega_input=as.factor(rep(NA,mesh$n))
,phi = as.factor(NA)
# ,log_tau_E = as.factor(NA)
,log_tau_O = as.factor(NA)
,log_kappa = as.factor(NA)
,rho = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
# library(TMBhelper)
myMap <- list()
UseMap <- TRUE
if(UseMap){
myMap <- list(Epsilon_input=as.factor(matrix(NA,nrow=mesh$n,ncol=Data$n_t))
,Omega_input=as.factor(rep(NA,mesh$n))
,phi = as.factor(NA)
,log_tau_E = as.factor(NA)
,log_tau_O = as.factor(NA)
,log_kappa = as.factor(NA)
,rho = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
rep$p
hist(rep$p)
hist(rep$p)
Data$n_x
Data$X_xp
source('C:/CHASCO/PROJECTS/SQUID/SpatialAnalysis_INLA.r', echo=TRUE)
rep$eta_p
rep$eta_x
Data$n_x
Parameters$alpha
Data$X_xp
source('~/.active-rstudio-document', echo=TRUE)
source('C:/CHASCO/PROJECTS/SQUID/test.r', echo=TRUE)
try(dyn.unload("test"))
rep
rep <- Obj$report()
dyn.load("test")
Data = list(i=1)
Parameters = list(p= 0)
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
hessian=TRUE,
DLL="test")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
rep <- Obj$report()
rep
# load libraries
library(INLA)
library(TMB)
library(RandomFields)
library(raster)
library(RANN)
source( "Sim_Gompertz_Fn.R" )
# Read data
set.seed( 2 )
Sim_List = Sim_Gompertz_Fn( n_years=10, n_stations=1000, SpatialScale=0.1, SD_O=0.4, SD_E=1, SD_extra=0, rho=0.5, logMeanDens=1, phi=-2, Loc=NULL )
DF = Sim_List[["DF"]]
loc_xy_orig = loc_xy = Sim_List[["Loc"]]
# Reduce sample sizes to 100 per year
Which2Keep = sample(1:nrow(DF), size=100*Sim_List$n_years, replace=FALSE)
Which2Drop = setdiff(1:nrow(DF),Which2Keep)
DF[Which2Drop,'Simulated_example'] = NA
# Reduce number of stations -- OPTIONAL
n_knots = 50
if( n_knots < nrow(loc_xy) ){
knots_xy = kmeans( x=loc_xy_orig, centers=n_knots )
# Modify data
loc_xy = knots_xy$centers
DF[,'Site'] = knots_xy$cluster[DF[,'Site']]
}
# Build SPDE object using INLA (must pass mesh$idx$loc when supplying Boundary)
mesh = inla.mesh.create( loc_xy, refine=TRUE, extend=-0.5 )
spde = inla.spde2.matern( mesh )
# Visualize mesh and predictive process
plot(mesh)
points( loc_xy_orig, cex=1.5, pch=20 )
points( loc_xy, cex=2, pch=3, col="green", lwd=5)
# Generate grid to visualize density
vizloc_xy = expand.grid( x=seq(0,1,by=0.001), y=seq(0,1,by=0.001) )
knots_xy = nn2( data=loc_xy_orig, query=vizloc_xy, k=1 )
# Plot densities
par( mfrow=c(2,5), mar=c(2,2,2,0), mgp=c(1.5,0.25,0) )
for( tI in 1:Sim_List$n_years ){
vizTheta_xy = array(Sim_List$Theta[ cbind(knots_xy$nn.idx,tI) ], dim=c(1001,1001) )
rasterTheta_xy = raster( vizTheta_xy )
plot( rasterTheta_xy, xlim=c(0,1), ylim=c(0,1), main=paste0("Year ",tI) )
}
Version = "spatial_gompertz_state_as_random"
Data = list( n_i=nrow(DF),
n_x=mesh$n,
n_t=max(DF$Year),
n_p=ncol(X_xp),
x_s=mesh$idx$loc-1,
c_i=DF[,'Simulated_example'],
s_i=DF[,'Site']-1, t_i=DF[,'Year']-1, X_xp=X_xp, G0=spde$param.inla$M0, G1=spde$param.inla$M1, G2=spde$param.inla$M2)
Data = list( n_i=nrow(DF),
n_x=mesh$n,
n_t=max(DF$Year),
n_p=ncol(X_xp),
x_s=mesh$idx$loc-1,
c_i=DF[,'Simulated_example'],
s_i=DF[,'Site']-1,
t_i=DF[,'Year']-1,
X_xp=X_xp,
G0=spde$param.inla$M0,
G1=spde$param.inla$M1,
G2=spde$param.inla$M2)
Data$X_xp
head(Data$X_xp)
Data$n_x
Parameters$eta_x
Parameters = list(alpha=c(0.0),
phi=0.0,
log_tau_U=1.0,
log_tau_O=1.0,
log_kappa=0.0,
rho=0.5,
log_D_xt=matrix(rnorm(mesh$n*Data$n_t),nrow=mesh$n,ncol=Data$n_t),
Omega_input=rnorm(mesh$n))
Parameters$Omega_input
Data$x_s
Data$s_i
range(Data$s_i)
range(Data$x_s)
Data$X_xp%*%Parameters$alpha
Data$X_xp%*%t(Parameters$alpha)
a.matrix(Data$X_xp)%*%t(Parameters$alpha)
dim(Data$X_xp)
Parameters = list(alpha=c(0.0),
phi=0.0,
log_tau_U=1.0,
log_tau_O=1.0,
log_kappa=0.0,
rho=0.5,
log_D_xt=matrix(rnorm(mesh$n*Data$n_t),nrow=mesh$n,ncol=Data$n_t),
Omega_input=rnorm(mesh$n))
710*26
source( "Sim_Gompertz_Fn.R" )
# Read data
set.seed( 2 )
Sim_List = Sim_Gompertz_Fn( n_years=10,
n_stations=1000,
SpatialScale=0.1,
SD_O=0.4,
SD_E=1,
SD_extra=0,
rho=0.5,
logMeanDens=1,
phi=-2,
Loc=NULL )
DF = Sim_List[["DF"]]
loc_xy_orig = loc_xy = Sim_List[["Loc"]]
# Reduce sample sizes to 100 per year
Which2Keep = sample(1:nrow(DF), size=100*Sim_List$n_years, replace=FALSE)
Which2Drop = setdiff(1:nrow(DF),Which2Keep)
DF[Which2Drop,'Simulated_example'] = NA
# Reduce number of stations -- OPTIONAL
n_knots = 50
if( n_knots < nrow(loc_xy) ){
knots_xy = kmeans( x=loc_xy_orig, centers=n_knots )
# Modify data
loc_xy = knots_xy$centers
DF[,'Site'] = knots_xy$cluster[DF[,'Site']]
}
# Build SPDE object using INLA (must pass mesh$idx$loc when supplying Boundary)
mesh = inla.mesh.create( loc_xy, refine=TRUE, extend=-0.5 )
spde = inla.spde2.matern( mesh )
# Visualize mesh and predictive process
plot(mesh)
points( loc_xy_orig, cex=1.5, pch=20 )
points( loc_xy, cex=2, pch=3, col="green", lwd=5)
# Generate grid to visualize density
vizloc_xy = expand.grid( x=seq(0,1,by=0.001), y=seq(0,1,by=0.001) )
knots_xy = nn2( data=loc_xy_orig, query=vizloc_xy, k=1 )
# Plot densities
par( mfrow=c(2,5), mar=c(2,2,2,0), mgp=c(1.5,0.25,0) )
for( tI in 1:Sim_List$n_years ){
vizTheta_xy = array(Sim_List$Theta[ cbind(knots_xy$nn.idx,tI) ], dim=c(1001,1001) )
rasterTheta_xy = raster( vizTheta_xy )
plot( rasterTheta_xy, xlim=c(0,1), ylim=c(0,1), main=paste0("Year ",tI) )
}
Version = "spatial_gompertz_state_as_random"
Version = "spatial_gompertz_state_as_random"
# Compile
compile( paste0(Version,".cpp") )
dyn.load( dynlib(Version) )
# Build inputs
X_xp = matrix( 1, ncol=1, nrow=mesh$n)
Data = list( n_i=nrow(DF),
n_x=mesh$n,
n_t=max(DF$Year),
n_p=ncol(X_xp),
x_s=mesh$idx$loc-1,
c_i=DF[,'Simulated_example'],
s_i=DF[,'Site']-1,
t_i=DF[,'Year']-1,
X_xp=X_xp,
G0=spde$param.inla$M0,
G1=spde$param.inla$M1,
G2=spde$param.inla$M2)
Data$X_xp
Parameters = list(alpha=c(0.0),
phi=0.0,
log_tau_U=1.0,
log_tau_O=1.0,
log_kappa=0.0,
rho=0.5,
log_D_xt=matrix(rnorm(mesh$n*Data$n_t),nrow=mesh$n,ncol=Data$n_t),
Omega_input=rnorm(mesh$n))
Data$s_i
range(Data$s_i)
range(Data$x_s)
length(Data$x_s)
Data$s_i
Data = list( n_i=n_i,
n_x=n_x,
n_t=n_t,
n_p=ncol(X_xp),
x_s=x_s,
c_i=c_i,
s_i=s_i,
t_i=t_i,
X_xp=X_xp,
G0=spde$param.inla$M0,
G1=spde$param.inla$M1,
G2=spde$param.inla$M2)
Data$X_xp
Data$s_i
range(Data$s_i)
range(Data$x_s)
library(INLA); library(sp); library(fields)
library(geoR)
library(viridisLite)
library(TMB)
library(ggthemes)
library(maps)
require(sp)
require(maptools)
require(ggplot2)
survey <- read.csv("SquidData.csv", sep=",", header = TRUE)
survey <- survey[!is.na(survey$Distance_Offshore_nmi),]
survey <- survey[survey$Study_Type=="Regular",]
stations <- unique(survey$Station)
df = data.frame(y = log(survey$California_market_squid_), locx = survey$Lon, locy = survey$Lat)
df = data.frame(y = log(survey$California_market_squid_),
locx = survey$Lon,
locy = survey$Lat)
# spatial.scaling = 1
# df$locx = (df$locx - min(df$locx))/spatial.scaling
# df$locy = (df$locy - min(df$locy))/spatial.scaling
df$dist = survey$Distance_Offshore_nmi - mean(survey$Distance_Offshore_nmi)
df$y = df$y-min(df$y)
max.edge = 0.99
mesh = inla.mesh.2d(loc=cbind(df$locx, df$locy),
max.edge = c(0.9,0.9), cutoff = 0.1)
n_i <- nrow(survey)
n_x <- mesh$n
n_t <- length(unique(survey$Year))
n_p <- 1 #number of covariates
x_s <- mesh$idx$loc - 1
x_s
range(x_s)
c_i <- survey$California_market_squid_
s_i <- data.frame(Station=survey$Station)
length(unique(Data$s_i))
length(unique(Data$x_s))
n_x
Parameters$alpha
Data = list( n_i=n_i,
n_x=n_x,
n_t=n_t,
n_p=ncol(X_xp),
x_s=x_s,
c_i=c_i,
s_i=s_i,
t_i=t_i,
X_xp=X_xp,
G0=spde$param.inla$M0,
G1=spde$param.inla$M1,
G2=spde$param.inla$M2)
Parameters = list(fp= 0,
alpha=rep(0.0),
alpha_p=rep(0.0),
fsd = 5.0,
phi=0.0,
log_tau_E=1.0,
log_tau_O=1.0,
log_kappa=0.0,
rho=0.5,
fs_sd = 0,
eps_s = unique(Data$s_i)*0,
Epsilon_input=matrix(0,nrow=mesh$n,ncol=Data$n_t),
Omega_input=rep(0,mesh$n))
unique(Data$s_i)
s_i
x_s <- mesh$idx$loc - 1
c_i <- survey$California_market_squid_
s_i <- data.frame(Station=survey$Station)
si_lu <- data.frame(s_i=1:length(unique(survey$Station)),Station=unique(survey$Station))
s_i <- merge(s_i,si_lu)$s_i-1
s_i
t_i <- survey[,'Year']-min(survey[,'Year'])
X_xp <- as.matrix(rep(1,n_x),n_x,1)
spde = inla.spde2.matern(mesh)
Data = list( n_i=n_i,
n_x=n_x,
n_t=n_t,
n_p=ncol(X_xp),
x_s=x_s,
c_i=c_i,
s_i=s_i,
t_i=t_i,
X_xp=X_xp,
G0=spde$param.inla$M0,
G1=spde$param.inla$M1,
G2=spde$param.inla$M2)
Parameters = list(fp= 0,
alpha=rep(0.0),
alpha_p=rep(0.0),
fsd = 5.0,
phi=0.0,
log_tau_E=1.0,
log_tau_O=1.0,
log_kappa=0.0,
rho=0.5,
fs_sd = 0,
eps_s = unique(Data$s_i)*0,
Epsilon_input=matrix(0,nrow=mesh$n,ncol=Data$n_t),
Omega_input=rep(0,mesh$n))
Random = c("Epsilon_input","Omega_input", "eps_s")
try(dyn.unload("squid"))
compile("squid.cpp")
dyn.load("squid")
try(dyn.unload("squid"))
compile("squid.cpp")
source('C:/CHASCO/PROJECTS/SQUID/SpatialAnalysis_INLA.r', echo=TRUE)
print(p)
dev.off()
rep$p
rep$Omega_x
# library(TMBhelper)
myMap <- list()
UseMap <- FALSE
if(UseMap){
myMap <- list(Epsilon_input=as.factor(matrix(NA,nrow=mesh$n,ncol=Data$n_t))
,Omega_input=as.factor(rep(NA,mesh$n))
,phi = as.factor(NA)
,log_tau_E = as.factor(NA)
,log_tau_O = as.factor(NA)
,log_kappa = as.factor(NA)
,rho = as.factor(NA)
)
}
# Make object
Obj = MakeADFun(data=Data,
parameters=Parameters,
random=Random,
map = myMap,
hessian=FALSE,
DLL="squid")
out <- nlminb(Obj$par,Obj$fn,Obj$gr)
rep$eps_s
hist(rep$eps_s)
# SD <- sdreport(Obj)
#
rep <- Obj$report()
hist(rep$eps_s)
#
n <- 300
xlim <- c(-125.5,-123.5)
ylim <- c(44,48.5)
proj = inla.mesh.projector(mesh, xlim = xlim,
ylim = ylim, dims=c(n, n))
field.proj = inla.mesh.project(proj, rep$Omega_x+rep$Epsilon_xt[,1])
DF <- data.frame(yr=rep(unique(survey$Year)[1],n*n),
x=rep(proj$x,300),
y=rep(proj$y,each=300),
dens = exp(c(as.matrix(field.proj))))
for(i in 2:ncol(rep$Epsilon_xt)){
field.proj = inla.mesh.project(proj, rep$Omega_x+rep$Epsilon_xt[,i])
DF_tmp <- data.frame(yr=rep(unique(survey$Year)[i],n*n),
x=rep(proj$x,300),
y=rep(proj$y,each=300),
dens = exp(c(as.matrix(field.proj))))
DF <- rbind(DF,DF_tmp)
}
DF$yr <- as.factor(DF$yr)
# get the map, don't plot it but `fill` gets us named 'map' polygons
world <- map("world", fill=TRUE, plot=FALSE)
# convert the 'map' to something we can work with via geom_map
IDs <- sapply(strsplit(world$names, ":"), function(x) x[1])
world <- map2SpatialPolygons(world, IDs=IDs, proj4string=CRS("+proj=longlat +datum=WGS84"))
# this does the magic for geom_map
world_map <- fortify(world)
myYears <- DF$yr%in%c(as.character(1998:2017))
p <- ggplot(DF[myYears,], aes(x, y)) +
geom_raster(aes(x, y, fill = dens)) +
scale_fill_gradientn(colours=c("#0000FFFF","#FFFFFFFF","#FF0000FF")) +
facet_wrap(~yr, nrow=2) +
scale_x_continuous(limits = c(min(DF$x),max(DF$x)), expand = c(0, 0)) +
scale_y_continuous(limits = c(min(DF$y),max(DF$y)), expand = c(0, 0)) +
theme_bw() +
ylab("Latitude") +
xlab("Longitude") +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank()) +
annotation_map(map_data("world")) +
theme_bw()+theme(plot.background = element_blank(),panel.grid.major = element_blank()
,panel.grid.minor = element_blank()) +labs(title="",y="", x="")+
theme(axis.title.x = element_text(face="bold", size=8,colour = rgb(0,0,0)),axis.text.x = element_text(size=8,colour = rgb(0,0,0)))+
theme(axis.title.y = element_text(face="bold", size=8,colour = rgb(0,0,0)),axis.text.y = element_text(size=8,colour = rgb(0,0,0)))+
theme(plot.title = element_text(lineheight=.8, face="bold",size=10,colour = rgb(0,0,0)))+
theme(
panel.background = element_rect(fill = "transparent",colour = NA),
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_rect(colour = "black", fill=NA, size=0.5))+
theme(legend.position="none")
# pdf("SpatialAnalysis_INLA.pdf", width = 7, height=10)
print(p)
rep$eps_s
rep$eps_s==0
sum(rep$eps_s==0)
rep$eta_x
source('C:/CHASCO/PROJECTS/SQUID/SpatialAnalysis_INLA.r', echo=TRUE)
source('C:/CHASCO/PROJECTS/SQUID/SpatialAnalysis_INLA.r', echo=TRUE)
# pdf("SpatialAnalysis_INLA.pdf", width = 7, height=10)
print(p)
rep$eps_s
hist(rep$eps_s)
hist(rep$eps_x)
hist(rep$eta_x)
rep$eta_x
rep$Omega_x
hist(rep$Omega_x)
rep$SigmaE
rep$SigmaO
rep$Range
rep$Equil_x
rep$Epsilon_xt
image(rep$Epsilon_xt)
dim(rep$Epsilon_xt)
image(t(rep$Epsilon_xt))
plot(colMeans(t(rep$Epsilon_xt)))
plot(rowMeans(t(rep$Epsilon_xt)))
plot(rowMeans(t(rep$Epsilon_xt)),type="l")
dim(exp(rep$log_chat_i))
exp(rep$log_chat_i)
